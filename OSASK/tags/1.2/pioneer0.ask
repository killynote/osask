/* "pioneer0":ぐいぐいの標準ライブラリ ver.1.1
    copyright(C) 2001 H.Kawai (川合秀実) */

/* これは、アプリケーションを書きやすくするための各種サービスを提供するプログラム。
   結局のところ、処理をshellcallに取り次いでいるだけ。
   shellcallの仕様は流動的なので、このライブラリがその変化を吸収しているともいえる。 */

/* スタックは1KBくらいあれば問題は無いだろう。 */

segment PioneerMdl(USE32, PARA);
default(code == PioneerMdl);

struct WORK { /* 256bytes */
	char signature[8]; int children_back, children_next;
	int softint_EIP, softint_CS, nest /* user用 */, read_ptr /* system用 */;
	int softint_ret_buf[16], softint_mask_buf[16]; /* system用 */
	int signalbox_read_free, signalbox_eos, signalbox_rewind, signaldw /* user用 */;
	int signalbox_write_free, signalbox_write_ptr,
		signalbox_write_ptr0, signalbox_write_ptr1; /* user用 */
	char signalbox_status, [15];
	/* 空きは144バイト */
};

struct WINDOW {	/* 128bytes */
	char signature[8];
	int chain_back, chain_next;
	int children_back, children_next;
	int x_size, y_size, x_ofs, y_ofs;
	int slot;
	unsigned char mode0, draw_enable, siglen, sigflag;
	int signalhead[16];
	/* 空きは64バイト */
};

struct TEXTBOX { /* 64bytes */
	char signature[8];
	int chain_back, chain_next;
	int x_size, y_size, x0, y0;
	int option, backcolor, charset, window;
	void [16]; /* 空きは16バイト */
	int buffer[0];
};

void near drawcomponent();
void near drawwindow();
void near textbox_drawback(); /* テキストボックスの背景描画ルーチン */

/*
	スロットの使用状況
		0x0000〜0x0170 : shell-call側でリザーブ
		0x01c0〜0x01e0 : システムタイマー
		0x01f0         : pioneerのワークエリア位置などを保存
		0x0200〜0x03f0 : ユーザーに解放
*/

void far pioneer0()
/* Lv3のライブラリー
   セグメントは、DS == FS == SSである事を仮定している。
   コマンドはDS:EBX以降に格納されている。 */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;
	segment PioneerMdl == CS;

	PUSHAD();
	(offset) cmd = EBX;
	if ((unsigned) cmd[0] != 0x0004) {
		/* 最初のコマンドが初期化コマンドではない */

		EBX = 0xffffffff;
		EAX = 0x0004; /* read user-slot command */
		ECX = 0x01f0; /* スロット番号(pioneerワークスロット) */
		DB(0x9a); DD(0); DW(0x0017); /* shell-call */
		(offset) work = EDX;

		/* softint禁止 */
		LEA(EBX, work->softint_mask_buf[0]); /* add_nest */
	//	work->softint_mask_buf[ 8] = 0xff80; /* (Llv変更しない) */
		(int) [DS:EBX + 8] = 0xff80;
		DB(0x9a); DD(0); DW(0x0017); /* shell-call(softint抑制) */
	}

asmout("nextcmd:");
	EAX = cmd[0];
	if ((unsigned) EAX < 0x00e0) {
		TEST(EAX, 0x03);
		if (== 0)
			asmout("JMP DWORD PTR CS:[EAX+#cmd_jumptable]");
	}

	/* コマンド番号エラー
	   EAX    受理されなかったコマンド番号
	   DS:ESI そのコマンドへのポインタ */

cmderr:
	LEA(EBX, work->softint_mask_buf[0]); /* add_nest(Llv変更しない) */
	DB(0x9a); DD(0); DW(0x0017); /* shell-call(softint許可) */
	(int) [SS:ESP + 16 /* EBX */] = (offset) cmd;
INT(0x03); /* コマンドエラーは許さない */
//	TEST(ESP, ESP); // ZF = 0
	POPAD();
	return;

	ALIGN(4);
cmd_jumptable:
	asmout("DD OFFSET cmd000,  OFFSET cmd004,  OFFSET cmd008,  OFFSET #cmderr");
	asmout("DD OFFSET cmd010,  OFFSET #cmderr, OFFSET cmd018,  OFFSET #cmderr");
	asmout("DD OFFSET cmd020,  OFFSET cmd024,  OFFSET cmd028,  OFFSET cmd02c ");
	asmout("DD OFFSET #cmderr, OFFSET #cmderr, OFFSET #cmderr, OFFSET cmd03c ");
	asmout("DD OFFSET cmd040,  OFFSET cmd044,  OFFSET cmd048,  OFFSET #cmderr");
	asmout("DD OFFSET #cmderr, OFFSET #cmderr, OFFSET #cmderr, OFFSET #cmderr");
	asmout("DD OFFSET cmd060,  OFFSET #cmderr, OFFSET cmd068,  OFFSET #cmderr");
	asmout("DD OFFSET cmd070,  OFFSET cmd074,  OFFSET cmd078,  OFFSET #cmderr");
	asmout("DD OFFSET cmd080,  OFFSET cmd084,  OFFSET #cmderr, OFFSET cmd08c ");
	asmout("DD OFFSET #cmderr, OFFSET #cmderr, OFFSET #cmderr, OFFSET #cmderr");
	asmout("DD OFFSET cmd0a0,  OFFSET #cmderr, OFFSET cmd0a8,  OFFSET cmd0ac ");
	asmout("DD OFFSET cmd0b0,  OFFSET #cmderr, OFFSET #cmderr, OFFSET #cmderr");
	asmout("DD OFFSET cmd0c0,  OFFSET cmd0c4,  OFFSET cmd0c8,  OFFSET #cmderr");
	asmout("DD OFFSET cmd0d0,  OFFSET #cmderr, OFFSET #cmderr, OFFSET #cmderr");

}

void far cmd000()
/* 終了コマンド */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	/* 待機中の割り込みを検査 */
	if (work->nest == 0) { /* 割り込みはマスクされていない */
		if (work->signalbox_read_free != 0) { /* バッファにシグナルがある */
			PUSH(EAX); /* ESP -= 4;の代わり */
			if ((unsigned) (int) [SS:ESP + 16 /* ESP */] != 1) {
				/* ハンドラからの帰還要求は出ていない */

				/* 新規割り込み
				   スタックの積み替え

				 <積み替え後のスタック構成>
				   +0 〜  +31 : PUSHADイメージ
				  +32 〜  +43 : EIP, CS, EFLAGS
				  +44 〜  +59 : ES, DS, FS, GS
				  +60 〜  +91 : PUSHADイメージ
				  +92 〜 +103 : EIP, CS, EFLAGS

				   +0 〜  +43は、shellcallルーチンのために用意する
							(読み込まれると取り去られる)
				  +44 〜 +103は、ハンドラが参照するために用意される */

				PUSH(GS);
				PUSH(FS);
				PUSH(DS);
				PUSH(ES);
				PUSHFD();
				ESP -= 40;
				EAX = (int) [SS:ESP +  64]; // EDI
				ECX = (int) [SS:ESP +  68]; // ESI
				EDX = (int) [SS:ESP +  72]; // EBP
				(int) [SS:ESP +  60] = EAX;
				(int) [SS:ESP +  64] = ECX;
				(int) [SS:ESP +  68] = EDX;
				EAX = (int) [SS:ESP +  80]; // EBX
				ECX = (int) [SS:ESP +  84]; // EDX
				EDX = (int) [SS:ESP +  88]; // ECX
				(int) [SS:ESP +  76] = EAX;
				(int) [SS:ESP +  80] = ECX;
				(int) [SS:ESP +  84] = EDX;
				EAX = (int) [SS:ESP +  92]; // EAX
				ECX = (int) [SS:ESP +  96]; // EIP
				EDX = (int) [SS:ESP + 100]; // CS
				(int) [SS:ESP +  88] = EAX;
				(int) [SS:ESP +  92] = ECX;
				(int) [SS:ESP +  96] = EDX;
				EAX = (int) [SS:ESP + 40]; // EFLAGS
				(int) [SS:ESP + 100] = EAX;
			} else {
				/* ハンドラからの帰還要求が出ている */

				/* スタックの上位(+44 〜 +103)は完成している
				   下位(+0 〜 +43)を作り直す */
				EAX = (int) [SS:ESP + 100]; // EFLAGS
				(int) [SS:ESP + 40] = EAX;
			}
			EAX = work->softint_EIP; /* ハンドラへのベクタ */
			ECX = work->softint_CS;
			(int) [SS:ESP + 32] = EAX;
			(int) [SS:ESP + 36] = ECX;
			(int) [SS:ESP + 12] = 2; /* リターン時のLlv */
			work->nest--; /* 割り込んだので、マスクカウントを減少 */
			PUSH(FS);
			LEA(EBX, work->softint_ret_buf[0]);
			work->softint_ret_buf[ 4] = 0;
			work->softint_ret_buf[ 8] = 0x0080; /* 割り込み抑制解除 */
			DB(0x9a); DD(0); DW(0x0017); /* GUIGUI統合shellcall */
			INT(0x03); /* エラーが無い限り、ここにはこない */
		}
	}

	/* ハンドラへの分岐はない */
	if ((unsigned) (int) [SS:ESP + 12] == 1) {
		/* 帰還 */
		ESP += 40; /* いらない部分を捨てる(EDI〜EAX, CS:EIP) */
		POP(ES);
		POP(DS);
		POP(EAX); /* FSへ直接ロードせずに、EAXに入れておく */
		POP(GS);
		(int) [SS:ESP + 12] = 2; /* リターン時のLlv */
		PUSH(EAX); /* ここで復帰後のFSを積む */
		LEA(EBX, work->softint_ret_buf[0]);
		work->softint_ret_buf[ 4] = 0;
		work->softint_ret_buf[ 8] = 0x0080; /* 割り込み抑制解除 */
		DB(0x9a); DD(0); DW(0x0017); /* GUIGUI統合shellcall */
		INT(0x03); /* エラーが無い限り、ここにはこない */
	}

	/* 何もないので、普通の正常終了 */
	LEA(EBX, work->softint_mask_buf[0]); /* add_nest(Llv変更しない) */
	DB(0x9a); DD(0); DW(0x0017); /* shell-call */
	(int) [SS:ESP + 16 /* EBX */] = (offset) cmd;
	CMP(EAX, EAX); /* ZF = 1, CF = 0 */
	POPAD();
	return;
}

void near cmd004()
/* pioneer0ライブラリ初期化コマンド */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	/* work初期化(256bytes)
	   optionフィールドをもつ(malloc領域などのため)
	   malloc領域などの設定は、別のコマンドであとからやる。 */
	(offset) work = cmd[4] /* opt */;
	(offset) cmd += 8;
	(int) work->signature[0] = 0x6e6f6970 ; /* pion */
	(int) work->signature[4] = 0x30726565 ; /* eer0 */
	LEA(EAX, work->children_back); 
	work->children_back = EAX;
	work->children_next = EAX;
	work->nest = 0xffffffff;
	work->read_ptr = 0;
	work->softint_ret_buf[ 0] = 0x0208;
	work->softint_ret_buf[12] = 0;
	work->signalbox_read_free = 0;
	work->softint_mask_buf[ 0] = 0x0204;
	work->softint_mask_buf[ 4] = 0;
	work->softint_mask_buf[ 8] = 0xff80;
	work->softint_mask_buf[12] = 0x0000;
	work->signaldw = 0;
	work->signalbox_write_ptr = 0xfffffffe;
	/* ベクタ初期化 */
	AX = CS;
	PUSH(FS);
	FS = AX;
	asmout("MOV EBX,OFFSET #cmd0004_cmd");
	DB(0x9a); DD(0); DW(0x0017); /* shell-call */
	POP(FS);
	/* slot 0x01f0に(offset) workを書き込み */
	PUSH((int) 0);
	PUSH((offset) work);
	ESP -= 8;
	PUSH((int) 0x01f0); /* slot-no. */
	PUSH((int) 0x0080); /* write user-slot */
	EBX = ESP;
	/* ユーザー割り込み抑制 */
	DB(0x9a); DD(0); DW(0x0017); /* shell-call */
	ESP += 24;
	asmout("JMP nextcmd");
	ALIGN(4);
cmd0004_cmd:
	asmout("DD 0200H, OFFSET pioneer_softint, 010000C7H, 0201H"); /* softint_vector */
	asmout("DD 0204H, 0, 0281H"); /* to Llv2(nestを80に) */
	asmout("DD 0300H, 01C0H"); /* 獲得(この時、インターバルモードが解除される) */
asmout("cmd004_cmd2:");
	asmout("DD 0310H, 01C0H"); /* 現在時刻設定 */
	asmout("DD 0318H, 01C0H, 0140H, 1, 0080H"); /* メッセージ設定 */
	DD(0x0000);
}

void near cmd008()
/* pioneer0ライブラリの終了
   オプションで、アプリ自体も終了するか、それともアプリは終了しないかを選べる
   現在は、オプションを確認することもなく、終了 */
{
	PUSH((int) 0);
	PUSH((int) 0); // reserve
	PUSH((int) 0x0040); /* タスク終了 */
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); /* GUIGUI統合shellcall */
}

void near cmd010()
/* softintベクタ設定 */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EAX = cmd[4] /* EIP */;
	ECX = cmd[8] /* CS */;
	(offset) cmd += 12;
	work->softint_EIP = EAX;
	work->softint_CS = ECX;
	asmout("JMP nextcmd");
}

void near cmd018()
/* wait signal */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EAX = cmd[8]; // signaldw
	EDI = cmd[4]; // opt
	work->signalbox_write_free += EAX;
	work->signalbox_read_free -= EAX;
	if ((unsigned) < 0) {
		/* 書き込んだ以上に、読み込んだと報告された。
		   これは許しがたいエラーである。 */

		INT(0x03); /* エラー処理未完成 */
	}
	ECX = work->signalbox_write_ptr;
	TEST(CL, 0x01);
	if (!= 0) {
		if (EAX != 0) {
			/* シグナルフルだったので、それを解除 */
			work->signalbox_write_ptr &= 0xfffffffc;
			PUSH((int) 0x0000); // eoc
			PUSH((int) 0xff02); // nest
			PUSH((int) 0); // signals
			PUSH((int) 0x0204); // add nest
			EBX = ESP;
			DB(0x9a); DD(0); DW(0x0017); /* GUIGUI統合shellcall */
			ESP += 16;
		}
	}
	if (EDI == 0x0080) {
		/* 帰還要求を表すために、スタック内のESP値を1にする。 */
		(int) [SS:ESP + 12 /* ESP */] = 1;
	}
	EAX = cmd[12]; // nest
	work->nest += EAX;

	(offset) cmd += 16;
	TEST(EDI, 0xffffff70);
	if (!= 0) {
		// 無効オプション指定
		INT(0x03); // エラー処理未完成
	}

	int slot == EAX;
	slot = 0x01c0;

	TEST(EDI, 0x08);
	if (!= 0) {
		// set now time
		PUSH((int) 0x0000);
		PUSH((int) /* 0x01c0 */ slot);
		PUSH((int) 0x0310); /* 現在時刻設定 */
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); /* shell-call */
		ESP += 12;
	}

	TEST(EDI, 0x04);
	if (!= 0) {
		/* add time */
		/* 本来なら最低加算時間のチェックがある */
		PUSH((int) 0x0000);
		PUSH(cmd[8]);
		PUSH(cmd[4]);
		PUSH(cmd[0]);
		(offset) cmd += 12;
		PUSH((int) /* 0x01c0 */ slot);
		PUSH((int) 0x0314); /* 時刻加算 */
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 24;
	}

	/* 以下はシグナルが溜まっていないときだけ有効 */
	if (work->signalbox_read_free == 0) {
		TEST(EDI, 0x02);
		if (!= 0) {
			// regist timer
			PUSH((int) 0x0000);
			PUSH((int) /* 0x01c0 */ slot);
			PUSH((int) 0x0308); /* タイマー登録 */
			EBX = ESP;
			DB(0x9a); DD(0); DW(0x0017); // shell-call
			ESP += 12;
		}
		TEST(EDI, 0x01);
		if (!= 0) {
			/* sleep */
			LEA(EBX, work->softint_mask_buf[0]); /* add_nest(Llv変更する) */
			work->softint_mask_buf[ 8] = 0x0080;
			DB(0x9a); DD(0); DW(0x0017); // shell-call

			LEA(EBX, work->softint_mask_buf[0]); /* add_nest(Llv変更しない) */
			work->softint_mask_buf[ 8] = 0xff80;
				/* ライブラリルーチン内に再入したので、割り込みマスク */
			DB(0x9a); DD(0); DW(0x0017); // shell-call
		}
		TEST(EDI, 0x02);
		if (!= 0) {
			/* cancel timer */
			PUSH((int) 0x0000);
			PUSH((int) /* 0x01c0 */ slot);
			PUSH((int) 0x030c); // タイマー解約
			EBX = ESP;
			DB(0x9a); DD(0); DW(0x0017); // shell-call
			ESP += 12;
		}
	}
	asmout("JMP nextcmd");
}

void near cmd020()
/* create new window.
   slotのbit0 : ユーザーシグナルハンドリング
   slotのbit1 : position offset指定
   今のところ、シグナル長1のみサポート */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	// WINDOW構造体の初期化など
	WINDOW *cmd0020_win == DS:EDI;
	(offset) cmd0020_win = cmd[ 4]; // work_ptr
	LEA(EAX, cmd0020_win->children_back); 
	cmd0020_win->children_back = EAX;
	cmd0020_win->children_next = EAX;
	LEA(EAX, cmd0020_win->chain_back);
	ECX = work->children_back;
	work->children_back = EAX;
	(int) [DS:ECX + 4] /* back->next */ = EAX;
	LEA(EAX, work->children_back);
	cmd0020_win->chain_back = ECX;
	cmd0020_win->chain_next = EAX;
	// signatureも初期化しなければいけない

	EAX = cmd[ 8]; // slot-no
	ECX = cmd[12]; // x-size
	EDX = cmd[16]; // y-size
	(offset) cmd += 20;
	TEST(AL, 0x01);
	(int) cmd0020_win->mode0 = 0;
	if (!= 0) {
		// シグナルハンドリング
		EBX = cmd[0];
		(short) cmd0020_win->siglen = BX;
		/* シグナル長(bit0-3), ハンドリング範囲(bit8-15)
		   値0 : ハンドリングしない
		   bit0 : enable(0)/disable(1)/redraw(2)/redraw2(3)
		   bit1 : move(4)
		   bit2 : setmode(5)
		   bit3 : close(6)
		   bit7は加算量scale(0はx1、1はx4)
		   残りの4bitはリザーブ
		   最小化はdisableで処理されるので、検知できない
		   clickやresizeは拡張系(8, 9) */
		EBX = cmd[4];
		(offset) cmd += 8;
		cmd0020_win->signalhead[0] = EBX;
	}
	TEST(AL, 0x02);
	if (== 0) {
		ECX += 8 + 8; /* 左右に8dotずつ確保 */
		EDX += 29 + 8; /* 上に29dot、下に8dot確保 */
		cmd0020_win->x_ofs =  8;
		cmd0020_win->y_ofs = 29;
	} else {
		PUSH(EDX);
		EDX = cmd[0]; // x-offset
		EBX = cmd[4]; // y-offset
		(offset) cmd += 8;
		cmd0020_win->x_ofs = EDX;
		cmd0020_win->y_ofs = EBX;
		POP(EDX);
	}
	EAX &= 0xfffffff0;
	cmd0020_win->x_size = ECX;
	cmd0020_win->y_size = EDX;
	cmd0020_win->slot = EAX;
	PUSH((int) 0 /* EOC */);
	PUSH((int) 0x0040 /* signal-base */);
	PUSH((int) 0x0140 /* signalbox(slot番号で指定) */);
	PUSH(EDX /* y-size */);
	PUSH(ECX /* x-size */);
	PUSH((offset) cmd0020_win /* user-no */);
	PUSH(EAX /* slot-no */);
	PUSH((int) 0x0100 /* cmd-no */);
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 32;
	asmout("JMP nextcmd");
}

void near cmd024()
/* windowクローズ */
/* これにつながっていた全てのコンポーネントも使えなくなる */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	WINDOW *cmd0024_win == DS:EDI;
	(offset) cmd0024_win = cmd[ 8]; // work_ptr
	(offset) cmd += 12;
	PUSH((int) 0 /* EOC */);
	PUSH(cmd0024_win->slot);
	PUSH((int) 0x0104 /* cmd-no */);
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 12;
	asmout("JMP nextcmd");
}

void near cmd028()
// open text box
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	WINDOW *cmd0028_win == DS:EDI;
	TEXTBOX *cmd0028_textbox == DS:EBX;
	(offset) cmd0028_textbox = cmd[ 8]; // work_ptr
	(offset) cmd0028_win = cmd[32]; // window
	(int) cmd0028_textbox->signature[0] = 0x54584554; // 'TEXT'
	LEA(EAX, cmd0028_textbox->chain_back);
	ECX = cmd0028_win->children_back;
	cmd0028_win->children_back = EAX;
	(int) [DS:ECX + 4] /* back->next */ = EAX;
	LEA(EAX, cmd0028_win->children_back);
	cmd0028_textbox->chain_back = ECX;
	cmd0028_textbox->chain_next = EAX;
	EAX = cmd[ 4]; // opt
	ECX = cmd[12]; // 
	TEST(EAX, 0x0001);
	if (== 0) {
		ECX = 0x0008;
		// titleの時は、アクティブかどうかによって色が変わるので、初期値を設定しない
	}
	cmd0028_textbox->option = EAX;
	cmd0028_textbox->backcolor = ECX;
	cmd0028_textbox->window = (offset) cmd0028_win;
	EAX = cmd[16]; // x_size(キャラクター数)
	ECX = cmd[20]; // y_size(キャラクター数)
	cmd0028_textbox->x_size = EAX;
	cmd0028_textbox->y_size = ECX;
	EAX = cmd[24]; // x0
	ECX = cmd[28]; // y0
	EAX += cmd0028_win->x_ofs;
	ECX += cmd0028_win->y_ofs;
	cmd0028_textbox->x0 = EAX;
	cmd0028_textbox->y0 = ECX;
	EDX = cmd[36]; // キャラクターセット(slot-no)
	ECX = cmd[40]; // space code.
	(offset) cmd += 44;

	// バッファの初期化
	cmd0028_textbox->charset = EDX;
	EAX = cmd0028_textbox->x_size;
	PUSH((offset) cmd0028_textbox);
	MUL(cmd0028_textbox->y_size);
	EDX = cmd0028_textbox->backcolor;
	EDX <<= 16;
	(offset) cmd0028_textbox += 64;
	do {
		(int) [cmd0028_textbox    ] = ECX;
		(int) [cmd0028_textbox + 4] = EDX;
		(offset) cmd0028_textbox += 8;
		EAX--;
	} while (!= 0);
	POP((offset) cmd0028_textbox);

	if (AL != cmd0028_win->draw_enable) { // AL == 0
		// もし、描画フラグが1なら、更新する(フレームを描くとか、背景色をセットするとか)。
		EAX = cmd0028_textbox->option;
		TEST(EAX, 0xf000);
		if (== 0) {
			TEST(AL, 0x01);
			if (!= 0) {
				EDX = cmd0028_win->slot;
				PUSH(ESI);
				ESI = (offset) cmd0028_textbox;
				// EDX:win_slot, ESI:textbox
				EAX = 0x0020;
				textbox_drawback();
				POP(ESI);
			}
		}
	}
	asmout("JMP nextcmd");
}

void near cmd02c()
// close text box
{
	// 全く未完成
	INT(0x03);
}

void near cmd040()
// put string
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	WINDOW *cmd0040_win == DS:EDI;
	TEXTBOX *cmd0040_textbox == DS:EBX;
	(offset) cmd0040_textbox = cmd[16];
	EAX = cmd[12]; // y_pos
	MUL(cmd0040_textbox->x_size);
	EAX += cmd[ 8]; // x_pos
	EDX = cmd0040_textbox->backcolor;
	CL = (char) cmd[4]; TEST(CL, 0x01); // option
	if (!= 0) {
		EDX = cmd[24]; // back_color
	}
	EDX <<= 16;
	EDX |= cmd[20]; // color
	(offset) cmd0040_win = cmd0040_textbox->window;
	ECX = cmd[28]; // length
	if (cmd0040_win->draw_enable != 0) {
		PUSHAD();
		ESP -= 512;
		EAX = cmd0040_win->slot;
		(int) [SS:ESP     ] = 0x0404; /* put text */
		(int) [SS:ESP +  4] = 0x0000; /* option */
		(int) [SS:ESP +  8] = EAX;
		(int) [SS:ESP + 32] = ECX; // length
		ECX = cmd0040_textbox->charset;
		EAX = cmd0040_textbox->option; TEST(EAX, 0xf000); // option
		(int) [SS:ESP + 28] = ECX; // charset
		if (== 0) {
			// normal
			EDX >>= 16;
			(int) [SS:ESP + 24] = EDX; // back_color
			ECX = cmd[12]; // y_pos
			EAX = cmd[ 8]; // x_pos
			ECX *= 8;
			EAX *= 8;
			DL = (char) cmd0040_textbox->option; TEST(DL, 0x10); // option
			if (== 0)
				ECX *= 2;
			EAX += cmd0040_textbox->x0;
			ECX += cmd0040_textbox->y0;
			EDX = cmd[20]; // color
			(int) [SS:ESP + 12] = EAX; /* x0 */
			(int) [SS:ESP + 16] = ECX; /* y0 */
			(int) [SS:ESP + 20] = EDX; // color
		} else {
			// title
			EAX = cmd0040_win->mode0;
			(int) [SS:ESP + 12] = 24; /* x0 */
			asmout("MOV EAX,CS:[EAX*4+wintitle_colortable]");
			(int) [SS:ESP + 16] =  4; /* y0 */
			ECX = EAX;
			EAX &= 0xff;
			ECX /= 256;
			(int) [SS:ESP + 20] = EAX; /* color */
			(int) [SS:ESP + 24] = ECX; /* backcolor */
		}
		(offset) cmd += 32;
		LEA(EBX, [SS:ESP + 36]);
		ECX = (int) [SS:ESP + 32]; // length
		do {
			EAX = *cmd;
			(offset) cmd += 4;
			(int) [DS:EBX] = EAX;
			EBX += 4;
			ECX--;
		} while (!= 0);
		(int) [DS:EBX] = /* 0 */ ECX;
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
		ESP += 512;
		POPAD();
	}
	(offset) cmd += 32;
	if (ECX != 0) {
		LEA(EBX, [(offset) cmd0040_textbox + EAX * 8 + 64]);
		do {
			EAX = *cmd;
			(offset) cmd += 4;
			(int) [DS:EBX    ] = EAX;
			(int) [DS:EBX + 4] = EDX;
			EBX += 8;
			ECX--;
		} while (!= 0);
	}
	asmout("JMP nextcmd");
	ALIGN(4);
	asmout("wintitle_colortable DD 0008H, 0708H, 0, 040FH");
}

void near cmd044()
// line & box (without graphicbox)
// windowを指定した場合、enableのチェックはしないので要注意

//  +00 : cmd
//  +04 : opt
//  +08 : 0(window)
//  +0c : color
//  +10 : x0
//  +14 : y0
//  +18 : x1
//  +1c : y1
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;
	WINDOW *win == DS:EBX;

	EDI = 0;
	ESP -= 36;
	EAX = cmd[ 4]; // opt
	(offset) win = cmd[ 8]; // window
	ECX = cmd[12]; // color
	EDX = EDI;
	if ((unsigned) (offset) win != 0xffffffff) {
		EDX = win->slot;
	}
	(int) [SS:ESP +  0] = 0x0400; // cmd
	(int) [SS:ESP +  4] = EAX; // opt
	(int) [SS:ESP +  8] = EDX; // slot
	(int) [SS:ESP + 28] = ECX; // color
	EDX = EDI;
	if ((unsigned) (offset) win != 0xffffffff) {
		EDX = win->x_ofs;
		EDI = win->y_ofs;
	}
	EAX = cmd[16]; // x0
	ECX = cmd[20]; // y0
	EAX += EDX;
	ECX += EDI;
	(int) [SS:ESP + 12] = EAX; // x0
	(int) [SS:ESP + 16] = ECX; // y0
	EAX = cmd[24]; // x1
	ECX = cmd[28]; // y1
	EAX += EDX;
	ECX += EDI;
	(offset) cmd += 32;
	(int) [SS:ESP + 20] = EAX; // x1
	(int) [SS:ESP + 24] = ECX; // y1
	(int) [SS:ESP + 32] = 0; // eoc
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ESP += 36;
	asmout("JMP nextcmd");
}

void near cmd048()
// put string(without textbox)
// windowを指定した場合、enableのチェックはしないので要注意

// +00 : cmd
// +04 : opt(bit0:backcolor-enable)
// +08 : 0/window
// +12 : charset
// +16 : x_pos(dot)
// +20 : y_pos(dot)
// +24 : color
// +28 : backcolor
// +32 : length

// optのbit0は調べていない。1だという前提。
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;
	WINDOW *win == DS:EBX;

	EAX = 0;
	ESP -= 512;
	(offset) win = cmd[ 8];
	ECX = EAX;
	EDX = EAX;
	if ((unsigned) (offset) win != 0xffffffff) {
		EAX = win->slot;
		ECX = win->x_ofs;
		EDX = win->y_ofs;
	}
	ECX += cmd[16]; // x_pos(dot)
	EDX += cmd[20]; // y_pos(dot)
	(int) [SS:ESP     ] = 0x0404; /* put text */
	(int) [SS:ESP +  4] = 0x0000; /* option */
	(int) [SS:ESP +  8] = EAX;
	(int) [SS:ESP + 12] = ECX; /* x0 */
	(int) [SS:ESP + 16] = EDX; /* y0 */
	EAX = cmd[24]; // color
	ECX = cmd[28]; // backcolor
	EDX = cmd[12]; // charset
	(int) [SS:ESP + 20] = EAX; // color
	(int) [SS:ESP + 24] = ECX; /* backcolor */
	(int) [SS:ESP + 28] = EDX; // charset
	ECX = cmd[32]; // length
	(offset) cmd += 36;
	(int) [SS:ESP + 32] = ECX; // length
	LEA(EBX, [SS:ESP + 36]);
	do {
		EAX = *cmd;
		(offset) cmd += 4;
		(int) [DS:EBX] = EAX;
		EBX += 4;
		ECX--;
	} while (!= 0);
	(int) [DS:EBX] = /* 0 */ ECX;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ESP += 512;
	asmout("JMP nextcmd");
}

void near cmd060()
// define signalbox
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EAX = work->signalbox_write_ptr;
	TEST(AL, 0x01);
	if (!= 0) {
		// シグナルフルだったので、それを解除
		PUSH((int) 0x0000); // eoc
		PUSH((int) 0xff02); // nest
		PUSH((int) 0); // signals
		PUSH((int) 0x0204); // add nest
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
		ESP += 16;
	}

	ECX = cmd[4]; // bytes /* bit0, 1はreserve */
	EAX = cmd[8]; // work_ptr
	ECX -= 4;
	LEA(EDX, [EAX + ECX]);
	ECX /= 4;
	work->signalbox_write_ptr = EAX;
	work->signalbox_write_ptr0 = EAX;
	work->signalbox_write_ptr1 = EDX;
	work->signalbox_write_free = ECX;
	work->signalbox_read_free = 0;
	ECX = cmd[12]; // eos
	EDX = cmd[16]; // rewind
	work->signalbox_eos = ECX;
	work->signalbox_rewind = EDX;
	(offset) cmd += 20;
	(int) [DS:EAX] = ECX; // eos
	asmout("JMP nextcmd");
}

void near cmd068()
// define signal
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EAX = cmd[4]; // opt
	TEST(AH, 0x30);
	if (!= 0) {
		// リザーブビット
		INT(0x03);
	}
	ECX = cmd[20]; // signal_length
	if ((unsigned) ECX >= 2) {
		// 1dwより長いシグナルには未対応
		INT(0x03);
	}
	if (ECX != 0) {
		// シェルに設定を送信：0x7f000001 signal
		EAX = cmd[8]; // device
		if (EAX == 0x0010 /* timer */) {
			PUSH((int) 0x0000);
			PUSH(cmd[24]); // signal
			PUSH((int) 0x7f000001);
			PUSH((int) 2 /* length */);
			PUSH((int) 0x0140);
			PUSH(cmd[12]); // timer slot-no
			PUSH((int) 0x0318);
			EBX = ESP;
			DB(0x9a); DD(0); DW(0x0017); // shell-call
			ESP += 28;
		} else if (EAX == 0x0100) {
			WINDOW *cmd0068_win == DS:EDX;
			(offset) cmd0068_win = cmd[16]; // window
			if (EAX != 0x0100 /* decoded keycode */) {
				INT(0x03);
			}
			PUSH((int) 0);
			PUSH((int) 0);
			PUSH((int) 0); // for purpose
			PUSH(cmd[24]); // signal
			PUSH((int) 0x7f000001);
			PUSH((int) 2);
			PUSH((int) 0x0140 /* system signalbox(slot番号で指定) */);
			// ここにウィンドウ番号を入れた方がいいのでは？
			// もちろん、これもデフォルトの要請であって、受理されるとは限らない。
			PUSH(cmd0068_win->slot);
			PUSH(cmd[12]); // keycode
			PUSH(cmd[ 8]); // device
			PUSH(cmd[ 4]); // opt
			PUSH((int) 0x0510); // signal設定
			EBX = ESP;
			DB(0x9a); DD(0); DW(0x0017); // shell-call
			ESP += 48;
		}
		(offset) cmd += 28;
		EAX = cmd[0];
		LEA((offset) cmd, [cmd + EAX * 4 + 4]);
		asmout("JMP nextcmd");
	} else {
		(offset) cmd += 24;
		EAX = cmd[0];
		LEA((offset) cmd, [cmd + EAX * 4 + 4]);
		asmout("JMP nextcmd");
	}
}

void near cmd070()
// タイマーノードオープン
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EDX = cmd[4];
	(offset) cmd += 8;
	if (EDX == 0x01c0) {
		// ユーザーモードに変更
		// 初期化する
cmd074_intervaloff:
		EAX = 0;
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EDX);
		PUSH((int) 0x031c); // インターバル指定
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 24;
		asmout("JMP nextcmd");
	}
	PUSH((int) 0x0000);
	PUSH(EDX);
	PUSH((int) 0x0300); // タイマーノード取得
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 12;
	asmout("JMP nextcmd");
asmout("cmd074_intervaloff EQU #cmd074_intervaloff");
}

void near cmd074()
// タイマーノードクローズ
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EDX = cmd[4];
	(offset) cmd += 8;
	if (EDX == 0x01c0) {
		// システムモードに変更
		// 初期化する

		AX = CS;
		PUSH(FS);
		FS = AX;
		asmout("MOV EBX,OFFSET cmd004_cmd2");
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		POP(FS);
		asmout("JMP cmd074_intervaloff");
	}
	PUSH((int) 0x0000);
	PUSH(EDX);
	PUSH((int) 0x0304); // タイマーノード返却
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 12;
	asmout("JMP nextcmd");
}

void near cmd078()
// タイマー設定
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	// signalはここで設定しない
	// 時刻やインターバルを設定
	// シグナル定義時のdeviceは0x0010

	EDI = cmd[4]; // optionフィールド
	EDX = cmd[8]; // slot
	(offset) cmd += 12;

	TEST(EDI, 0x20); // bit5 : 現在時刻ロード
	if (!= 0) {
		PUSH((int) 0x0000);
		PUSH(EDX);
		PUSH((int) 0x0310); // 現在時刻設定
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 12;
	}
	TEST(EDI, 0x10); // bit4 : 時刻加算(時刻フィールドを伴う)
	if (!= 0) {
		PUSH((int) 0);
		PUSH(cmd[8]);
		PUSH(cmd[4]);
		PUSH(cmd[0]);
		(offset) cmd += 12;
		PUSH(EDX);
		PUSH((int) 0x0314); // 時刻加算
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 24;
	}
	TEST(EDI, 0x08); // bit3 : インターバル指定(インターバルフィールドを伴う)
	if (!= 0) {
		PUSH((int) 0);
		PUSH(cmd[8]);
		PUSH(cmd[4]);
		PUSH(cmd[0]);
		(offset) cmd += 12;
		PUSH(EDX);
		PUSH((int) 0x031c); // インターバル指定
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 24;
	}
	TEST(EDI, 0x04); // bit2 : インターバル解除(単発モード)
	if (!= 0) {
		EAX = 0;
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EDX);
		PUSH((int) 0x031c); // インターバル指定
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 24;
	}
	TEST(EDI, 0x02); // bit1 : タイマー始動
	if (!= 0) {
		PUSH((int) 0x0000);
		PUSH(EDX);
		PUSH((int) 0x0308); // タイマー登録
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 12;
	}
	TEST(EDI, 0x01); // bit0 : タイマー停止
	if (!= 0) {
		PUSH((int) 0x0000);
		PUSH(EDX);
		PUSH((int) 0x030c); // タイマー解除
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // shell-call
		ESP += 12;
	}
	asmout("JMP nextcmd");
}

void near cmd080()
// サウンドトラックオープン
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;
	PUSH((int) 0);
	PUSH(cmd[8] /* reserve */);
	PUSH(cmd[4] /* opt & slot */);
	PUSH((int) 0x0600);
	(offset) cmd += 12;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 16;

	// sleep
	LEA(EBX, work->softint_mask_buf[0]); // add_nest(Llv変更する)
	work->softint_mask_buf[ 8] = 0x0080;
	DB(0x9a); DD(0); DW(0x0017); // shell-call

	LEA(EBX, work->softint_mask_buf[0]); // add_nest(Llv変更しない)
	work->softint_mask_buf[ 8] = 0xff80;
		// ライブラリルーチン内に再入したので、割り込みマスク
	DB(0x9a); DD(0); DW(0x0017); // shell-call

	asmout("JMP nextcmd");
}

void near cmd084()
// サウンドトラッククローズ
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;
	PUSH((int) 0);
	PUSH(cmd[4] /* opt & slot */);
	PUSH((int) 0x0604);
	(offset) cmd += 8;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 12;
	asmout("JMP nextcmd");
}

void near cmd08c()
// 周波数指定によるサウンドオン／オフ
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;
	PUSH((int) 0);
	PUSH(cmd[8]);
	PUSH(cmd[4] /* opt & slot */);
	PUSH((int) 0x060c);
	(offset) cmd += 12;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 16;
	asmout("JMP nextcmd");
}

void near cmd03c()
{
	WINDOW *win == DS:EDI;
	int *cmd == DS:ESI;

	EAX = cmd[4];
	(offset) win = cmd[8];
	TEST(AL, 0x01);
	if (!= 0) {
		// EBP, ESI, EDI以外は全て破壊
		drawwindow();
		EAX = cmd[4];
	}
	TEST(AL, 0x02);
	if (!= 0) {
		// EBP, ESI, EDI以外は全て破壊
		drawcomponent();
		EAX = cmd[4];
	}
	TEST(AH, 0x01);
	if (!= 0) {
		PUSH((int) 0);
		PUSH(win->slot);
		PUSH((int) 0x0140);
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
		ESP += 12;
	}
	TEST(AH, 0x02);
	if (!= 0) {
		PUSH((int) 0);
		PUSH(win->slot);
		PUSH((int) 0x0144);
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
		ESP += 12;
	}
	(offset) cmd += 12;
	asmout("JMP nextcmd");
}

void near cmd0a0()
/* ファイルハンドル初期化 */
{
	int *cmd == DS:ESI;
	PUSH((int) 0);
	PUSH(cmd[ 8] /* slot */);
	PUSH(cmd[ 4] /* opt */);
	PUSH((int) 0x0700);
	(offset) cmd += 12;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 16;
	asmout("JMP nextcmd");
}

void near cmd0a8()
/* コピーハンドル */
/* cmd, opt, slot(dest), slot(src) */
{
	int *cmd == DS:ESI;
	PUSH((int) 0);
	PUSH(cmd[12] /* slot(src) */);
	PUSH(cmd[ 8] /* slot(dest) */);
	PUSH(cmd[ 4] /* opt */);
	PUSH((int) 0x0708);
	(offset) cmd += 16;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 20;
	asmout("JMP nextcmd");
}

void near cmd0ac()
/* ディレクトリ移動 */
/* cmd, opt, slot, tag0, tag1, ..., -1 */
{
	int *cmd == DS:ESI;
	ESP -= 512;
	(int) [SS:ESP] = 0x070c; /* cmd */
	EAX = cmd[ 4]; /* opt */
	ECX = cmd[ 8]; /* slot */
	[SS:ESP + 508] = EBP;
	[SS:ESP + 504] = EAX;
	[SS:ESP + 500] = (offset) cmd;
	(offset) cmd += 12;
	LEA(EBP, [SS:ESP + 12]);
	[SS:ESP +   4] = EAX;	
	[SS:ESP +   8] = ECX;
	EAX = cmd[0];
	do {
		ECX = cmd[4];
		(offset) cmd += 8;
		[SS:EBP    ] = EAX;
		[SS:EBP + 4] = ECX;
		EBP += 8;
		ECX -= 8;
		if (!= 0) {
			do {
				EAX = *cmd;
				(offset) cmd += 4;
				[SS:EBP] = EAX;
				EBP += 4;
				ECX -= 4;
			} while (!= 0);
		}
		EAX = cmd[0];
	} while (EAX != 0xffffffff);
	(offset) cmd += 4;
	(int) [SS:EBP    ] = EAX;
	(int) [SS:EBP + 4] = 0;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	asmout("TEST BYTE PTR SS:[ESP+504],01H");
	if (!= 0) {
		EBX = [SS:ESP + 500]; /* old cmd */
		EAX = [SS:ESP +   4];
		[DS:EBX + 4] = EAX;
	}
	EBP = [SS:ESP + 508];
	ESP += 512;
	asmout("JMP nextcmd");
}

void near cmd0b0()
/* create new module */
/* cmd, opt, slot(dir), slot(module), tag-dir alloc-size, tag0, tag1, ..., -1 */
{
	int *cmd == DS:ESI;
	ESP -= 512;
	EAX = cmd[ 4];
	ECX = cmd[ 8];
	[SS:ESP + 508] = EBP;
	EBP = ESP;
	EDX = cmd[12];
	EBX = cmd[16];
	(offset) cmd += 20;
	(int) [SS:EBP +  0] = 0x0710;
	[SS:EBP +  4] = EAX;
	[SS:EBP +  8] = ECX;
	[SS:EBP + 12] = EDX;
	[SS:EBP + 16] = EBX;
	EBP += 20;
	EAX = cmd[0];
	do {
		ECX = cmd[4];
		(offset) cmd += 8;
		[SS:EBP    ] = EAX;
		[SS:EBP + 4] = ECX;
		EBP += 8;
		ECX -= 8;
		if (!= 0) {
			do {
				EAX = *cmd;
				(offset) cmd += 4;
				[SS:EBP] = EAX;
				EBP += 4;
				ECX -= 4;
			} while (!= 0);
		}
		EAX = cmd[0];
	} while (EAX != 0xffffffff);
	(offset) cmd += 4;
	(int) [SS:EBP    ] = EAX;
	(int) [SS:EBP + 4] = 0;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	EBP = [SS:ESP + 508];
	ESP += 512;
	asmout("JMP nextcmd");
}

void near cmd0c0()
/* モジュールのメモリマッピング */
{
	int *cmd == DS:ESI;
	PUSH((int) 0);
	PUSH(cmd[20] /* ofs & attr */);
	PUSH(cmd[16] /* addr */);
	PUSH(cmd[12] /* size */);
	PUSH(cmd[ 8] /* slot */);
	PUSH(cmd[ 4] /* opt */);
	PUSH((int) 0x0720);
	(offset) cmd += 24;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 28;
	asmout("JMP nextcmd");
}

void near cmd0c4()
/* モジュールのアンマッピング */
{
	int *cmd == DS:ESI;
//	PUSH((int) 0);
//	PUSH(cmd[12] /* addr */);
//	PUSH(cmd[ 8] /* size */);
//	PUSH(cmd[ 4] /* opt */);
//	PUSH((int) 0x0720);
	(offset) cmd += 16;
//	EBX = ESP;
//	DB(0x9a); DD(0); DW(0x0017); // shell-call
//	ESP += 28;
	asmout("JMP nextcmd");
}

void near cmd0c8()
/* tag read */
/* cmd, opt, slot, bufsize, bufptr(near) */
/* opt == 0xffffff01 : module type code(8bytes) */
/* opt == 0xffffff03 : module size(16bytes) */
/* directoryに対してモジュールサイズを要求することはできない */
{
	int *cmd == DS:ESI;
	PUSH((int) 0);
	PUSH(DS /* bufptr(sel) */);
	PUSH(cmd[16] /* bufptr(ofs) */);
	PUSH(cmd[12] /* bufsize */);
	PUSH(cmd[ 8] /* slot */);
	PUSH(cmd[ 4] /* opt */);
	PUSH((int) 0x0728);
	(offset) cmd += 20;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 28;
	asmout("JMP nextcmd");
}

void near cmd0d0()
/* tag listing */
/* opt == 0xffffff00 : module name */
{
	int *cmd == DS:ESI;
	PUSH((int) 0);
	PUSH(DS /* bufptr(sel) */);
	PUSH(cmd[16] /* bufptr(ofs) */);
	PUSH(cmd[12] /* bufsize */);
	PUSH(cmd[ 8] /* slot */);
	PUSH(cmd[ 4] /* opt */);
	PUSH((int) 0x0730);
	(offset) cmd += 20;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	ESP += 28;
	asmout("JMP nextcmd");
}


void near sendusersignal()
// ES:EDIからのECX[dw]を送信
// ESI, EBP以外のレジスタは破壊される
// 送信に失敗したら、フラグで伝達(ZF == 0はエラー)
{
	WORK *work == SS:EBP;
	EDX = work->signalbox_write_ptr;
	TEST(DL, 0x03);
	if (== 0) {
		LEA(EAX, [EDX + ECX * 4]);
		if ((unsigned) EAX >= work->signalbox_write_ptr1 /* 書き込み上限アドレス */) {
			/* 先頭に戻す */
			/* 捨てるdw数を計算 */
			EAX = work->signalbox_write_ptr1;
			EAX -= EDX;
			EAX /= 4; // EAX == 先頭に戻すことによって消費するサイズ(dw単位)
			work->signalbox_read_free += EAX;
			work->signalbox_write_free -= EAX;
			if ((unsigned) <= 0) {
				work->signalbox_read_free -= EAX;
				work->signalbox_write_free += EAX;
				TEST(ESP, ESP); // ZF = 0
				return;
			} else {
				EBX = work->signalbox_rewind;
				[DS:EDX + 4] = EAX;
				[DS:EDX] = EBX;
				EDX = work->signalbox_write_ptr0;
			}
		}
		work->signalbox_read_free += ECX;
		work->signalbox_write_free -= ECX;
		if ((unsigned) <= 0) {
			// ユーザー用のsignalboxがあふれた
			work->signalbox_read_free -= ECX;
			work->signalbox_write_free += ECX;
			TEST(ESP, ESP); // ZF = 0
			EAX = work->signalbox_eos;
			work->signalbox_write_ptr = EDX;
			(int) [DS:EDX] = EAX;
			return;
		}
		do {
			EAX = [ES:EDI];
			EDI += 4;
			(int) [DS:EDX] = EAX;
			EDX += 4;
			ECX--;
		} while (!= 0); // ZF == 1
		EAX = work->signalbox_eos;
		work->signalbox_write_ptr = EDX;
		(int) [DS:EDX] = EAX;
		// nestによらず、目を覚まさせる
	//	(char) [SS:ESP + 12 /* GS, DS */ + 16] = 0x02; // リターン時にLlv2へ。
	}
	return;
}

// ユーザーシグナルボックスがないうちに、ユーザーシグナルが来たら、シグナルをマスク

void far pioneer_softint()
{
	WORK *work == SS:EBP;
	int *signal == GS:ESI;

	PUSH(DS);
	PUSH(ES);
	PUSH(GS);
	AX = SS;
	ECX = 0x0027; // system signalbox selector
	DS = AX;
	FS = AX;
	GS = CX;

	EBX = 0xffffffff;
	EAX = 0x0004; // リードユーザースロットコマンド
	ECX = 0x01f0;
	DB(0x9a); DD(0); DW(0x0017); // shell-call
	(offset) work = EDX;

	(offset) signal = work->read_ptr;
	work->signaldw = 0;
	do {
		EAX = signal[0];
		if (EAX == 0) {
			// terminate
			break;
		}
		if ((signed) <)
			goto usersignal;
		if ((unsigned) EAX >  0x7f0000ff)
			goto undefined;
		if ((unsigned) EAX >= 0x7f000000)
			goto headercut;
		if (EAX == 0x0080)
			goto sig0080; // system-timer time out
		if (EAX == 1)
			goto sig0001; // rewind
		if (EAX == 0x40)
			goto sig0040; // set window position
		if (EAX == 0x41)
			goto sig0041; // change window title-bar color
		if (EAX == 0x42)
			goto sig0042; // VRAM access enable(window)
		if (EAX == 0x43)
			goto sig0043; // close window
		if (EAX == 0x44)
			goto sig0044; // VRAM access disable(window)
		if (EAX == 0x48)
			goto sig0048; // redraw window
		if (EAX == 0xc0)
			goto sig00c0; // open sound track
		if (EAX == 0xc8)
			goto sig00c8; // enable sound track
		INT(0x03);

usersignal:
	// ユーザーシグナル：未対応
	INT(0x03);

undefined:
	// 未定義のシグナル
	INT(0x03);

headercut:
	// ユーザーシグナル(ヘッダーカット)
	EAX &= 0xff;
	EDX = 0x0027; // system signalbox selector
	ECX = EAX;
	EAX++;
	ES = DX;
	PUSH(EAX);
//	EDI = (offset) signal + 4;
	LEA(EDI, [ESI + 4]);
	sendusersignal();
	POP(EAX);
	if (ZF == 1 /* succeeded */) {
		work->signaldw += EAX;
		LEA(ESI, [ESI + EAX * 4]);
		(char) [SS:ESP + 12 /* GS, ES, DS */ + 16] = 0x02; // リターン時にLlv2へ。
		goto nextsignal;
	}
//	goto usersigboxfull;

usersigboxfull:
	// nestを0x02だけ減らす。
	work->signalbox_status |= 0x01 /* buffer-full */;
	work->signalbox_write_ptr |= 0x01 /* buffer-full */;
	EAX = work->signaldw; // それまでに処理できたシグナル
	POP(GS);
	POP(ES);
	POP(DS);
	LEA(EBX, work->softint_ret_buf[0]);
	work->softint_ret_buf[ 4] /* (int) [DS:EBX + 4] */ = EAX;
	work->softint_ret_buf[ 8] /* (int) [DS:EBX + 8] */ = 0x00ff; // さらに1引く
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	// 割り込みから復帰してしまう

sig0080:
	// システムタイマータイムアウト
	(offset) signal += 4;
	work->signaldw++;
	(char) [SS:ESP + 12 /* GS, ES, DS */ + 16 /* ESP */] = 0x02; // リターン時にLlv2へ。
	goto nextsignal;

sig00c0:
	// open sound track
	EDX = signal[4]; // slot
	EAX = signal[8]; // system-id
	(offset) signal += 12;
	work->signaldw += 3;
	(char) [SS:ESP + 12 /* GS, ES, DS */ + 16 /* ESP */] = 0x02; // リターン時にLlv2へ。
	EDX |= 0x01; // system-id defined
	PUSH((int) 0);
	PUSH(EAX);
	PUSH(EDX);
	PUSH((int) 0x0600);
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ESP += 16;
	goto nextsignal;

sig00c8:
	// enable sound track
	EDX = signal[4]; // slot
	(offset) signal += 8;
	work->signaldw += 2;
	EDX |= 0x01; // enable
	PUSH((int) 0);
	PUSH(EDX);
	PUSH((int) 0x0608);
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ESP += 12;
	goto nextsignal;

sig0001:
	// rewind
	EAX = signal[4];
	(offset) signal = 0;
	work->signaldw += EAX;
	goto nextsignal;

sig0040:
	// window位置変更
	// 描画は全てwindow相対モードを使うので、このシグナルに応じる必要が無い
	WINDOW *sig0040_win == DS:EBX;
	(offset) sig0040_win = signal[4];
//	EAX = signal[ 8];
//	ECX = signal[12];
//	*win_x0 = EAX; // win_x0
//	*win_y0 = ECX; // win_y0
	AL = sig0040_win->sigflag;
	TEST(AL, 0x02);
	if (!= 0) {
		EDI = 4;
		TEST(AL, 0x80);
		EDX = sig0040_win->signalhead[0];
		if (!= 0)
			EDI *= 4;
		CX = SS;
		EDX += EDI;
		ES = CX;
		PUSH(signal[12]);
		PUSH(signal[ 8]);
		PUSH(EDX);
		ECX = 3;
		EDI = ESP;
		sendusersignal();
		LEA(ESP, [SS:ESP + 12]);
		if (ZF == 0 /* error */)
			goto usersigboxfull;
		(char) [SS:ESP + 12 /* GS, ES, DS */ + 16] = 0x02; // リターン時にLlv2へ。
	}
	(offset) signal += 16;
	work->signaldw += 4;
	goto nextsignal;

sig0041:
	// タイトルバーカラー変更
	// bit0 : 0 = 長期にわたり、自由表示disable, 1 = enable
	// bit1 : 0 = 入力アクティブではない, 1 = 入力アクティブ
	// ぐいぐいでは、10の組み合わせをしないことを保証している。重なっていると入力アクティブにならない。
	// 入力アクティブになると、カーソルを表示する。

	WINDOW *sig0041_win == DS:EBX;
	(offset) sig0041_win = signal[4];
	AL = (char) signal[8];
	sig0041_win->mode0 = AL;
	AL = sig0041_win->sigflag;
	TEST(AL, 0x04);
	if (!= 0) {
		EDI = 5;
		TEST(AL, 0x80);
		EDX = sig0041_win->signalhead[0];
		if (!= 0)
			EDI *= 4;
		CX = SS;
		EDX += EDI;
		ES = CX;
		PUSH(signal[8]);
		PUSH(EDX);
		ECX = 2;
		EDI = ESP;
		sendusersignal();
		POP(EAX);
		POP(EDI);
		if (ZF == 0 /* error */)
			goto usersigboxfull;
		(char) [SS:ESP + 12 /* GS, ES, DS */ + 16] = 0x02; // リターン時にLlv2へ。
	}
	(offset) signal += 12;
	work->signaldw += 3;
	goto nextsignal;

sig0042:
	// VRAMアクセスの自由化
	WINDOW *sig0042_win == DS:EBX;
	(offset) sig0042_win = signal[4];
	AL = sig0042_win->sigflag;
	sig0042_win->draw_enable = 1; // 自由表示enable（随時更新）
	TEST(AL, 0x01);
	if (!= 0) {
		CX = SS;
		PUSH(sig0042_win->signalhead[0]);
		ES = CX;
		ECX = 1;
		EDI = ESP;
		sendusersignal();
		POP(EAX);
		if (ZF == 0 /* error */)
			goto usersigboxfull;
		(char) [SS:ESP + 12 /* GS, ES, DS */ + 16] = 0x02; // リターン時にLlv2へ。
	}
	(offset) signal += 8;
	work->signaldw += 2;
	goto nextsignal;

sig0043:
	// ウィンドウクローズ要求
	WINDOW *sig0043_win == DS:EBX;
	(offset) sig0043_win = signal[4];
	AL = sig0043_win->sigflag;
	TEST(AL, 0x08);
	if (!= 0) {
		EDI = 6;
		TEST(AL, 0x80);
		EDX = sig0043_win->signalhead[0];
		if (!= 0)
			EDI *= 4;
		CX = SS;
		EDX += EDI;
		ES = CX;
		PUSH(EDX);
		ECX = 1;
		EDI = ESP;
		sendusersignal();
		POP(EAX);
		if (ZF == 0 /* error */)
			goto usersigboxfull;
		(char) [SS:ESP + 12 /* GS, ES, DS */ + 16] = 0x02; // リターン時にLlv2へ。
		(offset) signal += 8;
		work->signaldw += 2;
		goto nextsignal;
	}
	PUSH((int) 0);
	PUSH((int) 0); // reserve
	PUSH((int) 0x0040); // タスク終了
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall

sig0044:
	// VRAMアクセスの凍結
	WINDOW *sig0044_win == DS:EBX;
	(offset) sig0044_win = signal[4];
	AL = sig0044_win->sigflag;
	TEST(AL, 0x01);
	sig0044_win->draw_enable = 0; // 自由表示disable（更新抑制）
	if (!= 0) {
		EDI = 1;
		TEST(AL, 0x80);
		EDX = sig0044_win->signalhead[0];
		if (!= 0)
			EDI *= 4;
		CX = SS;
		EDX += EDI;
		ES = CX;
		PUSH(EDX);
		ECX = 1;
		EDI = ESP;
		sendusersignal();
		POP(EAX);
		if (ZF == 0 /* error */)
			goto usersigboxfull;
		(char) [SS:ESP + 12 /* GS, ES, DS */ + 16] = 0x02; // リターン時にLlv2へ。
	} else {
		// 受理したことをシェルにシステムコールで伝える
		PUSH((int) 0);
		PUSH(sig0044_win->slot);
		PUSH((int) 0x0140);
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
		ESP += 12;
	}
	(offset) signal += 8;
	work->signaldw += 2;
	goto nextsignal;

sig0048:
	// 再描画(他のタスクによって、持ち場が荒らされた)
	WINDOW *sig0048_win == DS:EBX, *sig0048_win2 == DS:EDI;
	(offset) sig0048_win = signal[4];
	AL = sig0048_win->sigflag;
	TEST(AL, 0x01);
	if (!= 0) {
		EDI = 2;
		TEST(AL, 0x80);
		EDX = sig0048_win->signalhead[0];
		if (!= 0)
			EDI *= 4;
		CX = SS;
		EDX += EDI;
		ES = CX;
		PUSH(EDX);
		ECX = 1;
		EDI = ESP;
		sendusersignal();
		POP(EAX);
		if (ZF == 0 /* error */)
			goto usersigboxfull;
		(char) [SS:ESP + 12 /* GS, ES, DS */ + 16] = 0x02; // リターン時にLlv2へ。
	} else {
		EDI = (offset) sig0048_win;
		// EBP, ESI, EDI以外は全て破壊
		drawwindow();
		drawcomponent();
		// 描画完了通知シグナル
		PUSH((int) 0);
		PUSH(sig0048_win2->slot);
		PUSH((int) 0x0144);
		EBX = ESP;
		DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
		ESP += 12;
	}
	(offset) signal += 8;
	work->signaldw += 2;
//	goto nextsignal;

nextsignal:
		// モードチェンジ、window位置変更、VRAMアクセスの自由化の後には、再描画が来るのをあてにしてよい。
	} while (work->signaldw < 8);

	POP(GS);
	POP(ES);
	POP(DS);

	work->read_ptr = (offset) signal;

	// スタックを乱してリターンしてはいけない
	EAX = work->signaldw;
	LEA(EBX, work->softint_ret_buf[0]);
	work->softint_ret_buf[ 4] = EAX;
	work->softint_ret_buf[ 8] = 0x0001;
	if (work->nest == 0) {
		if (work->signalbox_read_free != 0) {
			if ((unsigned) (short) [SS:ESP + 40 /* CS */] != 0x00c7) {
				// 新規割り込み
				POP(EAX); // FS
				PUSH(GS);
				PUSH(EAX);
				PUSH(DS);
				PUSH(ES);
				ESP -= 44;
				PUSH(EAX);
				EAX = work->softint_EIP;
				ECX = work->softint_CS;
				EDX = (int) [SS:ESP + 104 /* EFLAGS */];
				(int) [SS:ESP + 16] = 0x02; // リターン時にLlv2へ。
				(int) [SS:ESP + 36 /* EIP */   ] = EAX;
				(int) [SS:ESP + 40 /* CS */    ] = ECX;
				(int) [SS:ESP + 44 /* EFLAGS */] = EDX;
				work->nest--;
			}
		}
	}
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	// エラーがない限り、ここには来ない
	INT(0x03);
//	ALIGN(4);
//wintitle_colortable:
//	asmout("wintitle_colortable DD 0008H, 0708H, 0, 040FH");
}

void near drawwindow()
{
	WINDOW *win == DS:EDI;

	// 枠を描く
	PUSH(ESI);
	PUSH(EBP);
	EDX = win->slot;
	ESP -= 512;
	EAX = win->x_size;
	ECX = win->y_size;
	EAX--;
	ECX--;
	EBP = 0;
	ESI = 0x0400;
	EBX = 0x0020;
	(int) [SS:ESP      ] = /* 0x0400 */ ESI /* line command */;
	(int) [SS:ESP +   4] = /* 0x0020 */ EBX /* option(box-fill) */;
	(int) [SS:ESP +   8] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  12] = /*  0 */ EBP /* x0 */;
	(int) [SS:ESP +  16] = /*  0 */ EBP /* y0 */;
	(int) [SS:ESP +  20] = EAX /* x1 */;
	(int) [SS:ESP +  24] = /*  0 */ EBP /* y1 */;
	(int) [SS:ESP +  28] =  8 /* color */;
	(int) [SS:ESP +  32] = /* 0x0400 */ ESI /* line command */;
	(int) [SS:ESP +  36] = /* 0x0020 */ EBX /* option(box-fill) */;
	(int) [SS:ESP +  40] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  44] = /*  0 */ EBP /* x0 */;
	(int) [SS:ESP +  48] = /*  0 */ EBP /* y0 */;
	(int) [SS:ESP +  52] = /*  0 */ EBP /* x1 */;
	(int) [SS:ESP +  56] = ECX /* y1 */;
	(int) [SS:ESP +  60] =  8 /* color */;
	(int) [SS:ESP +  64] = /* 0x0400 */ ESI /* line command */;
	(int) [SS:ESP +  68] = /* 0x0020 */ EBX /* option(box-fill) */;
	(int) [SS:ESP +  72] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  76] = /*  0 */ EBP /* x0 */;
	(int) [SS:ESP +  80] = ECX /* y0 */;
	(int) [SS:ESP +  84] = EAX /* x1 */;
	(int) [SS:ESP +  88] = ECX /* y1 */;
	(int) [SS:ESP +  92] = /* 0 */ EBP /* color */;
	(int) [SS:ESP +  96] = /* 0x0400 */ ESI /* line command */;
	(int) [SS:ESP + 100] = /* 0x0020 */ EBX /* option(box-fill) */;
	(int) [SS:ESP + 104] = EDX /* window(slot-no) */;
	(int) [SS:ESP + 108] = EAX /* x0 */;
	(int) [SS:ESP + 112] = /*  0 */ EBP /* y0 */;
	(int) [SS:ESP + 116] = EAX /* x1 */;
	(int) [SS:ESP + 120] = ECX /* y1 */;
	(int) [SS:ESP + 124] = /* 0 */ EBP /* color */;
	(int) [SS:ESP + 128] = /* 0x0000 */ EBP /* end of command */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	EAX--;
	ECX--;
//	EBP++; // EBP = 1;
//	ESI = 15;
//	EBX = 7;
	LEA(ESI, [EBP /* 0 */ + 15]);
	LEA(EBX, [EBP /* 0 */ + 7]);
	EBP++;
//	(int) [SS:ESP      ] = 0x0400 /* line command */;
//	(int) [SS:ESP +   4] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +   8] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  12] = /*  1 */ EBP /* x0 */;
	(int) [SS:ESP +  16] = /*  1 */ EBP /* y0 */;
	(int) [SS:ESP +  20] = EAX /* x1 */;
	(int) [SS:ESP +  24] = /*  1 */ EBP /* y1 */;
	(int) [SS:ESP +  28] = 15 /* color */;
//	(int) [SS:ESP +  32] = 0x0400 /* line command */;
//	(int) [SS:ESP +  36] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +  40] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  44] = /*  1 */ EBP /* x0 */;
	(int) [SS:ESP +  48] = /*  1 */ EBP /* y0 */;
	(int) [SS:ESP +  52] = /*  1 */ EBP /* x1 */;
	(int) [SS:ESP +  56] = ECX /* y1 */;
	(int) [SS:ESP +  60] = 15 /* color */;
//	(int) [SS:ESP +  64] = 0x0400 /* line command */;
//	(int) [SS:ESP +  68] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +  72] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  76] = /*  1 */ EBP /* x0 */;
	(int) [SS:ESP +  80] = ECX /* y0 */;
	(int) [SS:ESP +  84] = EAX /* x1 */;
	(int) [SS:ESP +  88] = ECX /* y1 */;
	(int) [SS:ESP +  92] =  7 /* color */;
//	(int) [SS:ESP +  96] = 0x0400 /* line command */;
//	(int) [SS:ESP + 100] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP + 104] = EDX /* window(slot-no) */;
	(int) [SS:ESP + 108] = EAX /* x0 */;
	(int) [SS:ESP + 112] = /*  1 */ EBP /* y0 */;
	(int) [SS:ESP + 116] = EAX /* x1 */;
	(int) [SS:ESP + 120] = ECX /* y1 */;
	(int) [SS:ESP + 124] =  7 /* color */;
//	(int) [SS:ESP + 128] = 0x0000 /* end of command */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	EAX--;
	ECX--;
	EBP++; // EBP = 2;
	ESI = 0;
//	(int) [SS:ESP      ] = 0x0400 /* line command */;
//	(int) [SS:ESP +   4] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +   8] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  12] = /*  2 */ EBP /* x0 */;
	(int) [SS:ESP +  16] = /*  2 */ EBP /* y0 */;
	(int) [SS:ESP +  20] = EAX /* x1 */;
	(int) [SS:ESP +  24] = ECX /* y1 */;
	(int) [SS:ESP +  28] =  8 /* color */;
	ECX = win->mode0;
	EAX--;
	EBP++; // EBP = 3;
	asmout("MOV ECX,CS:[ECX*4+wintitle_colortable]");
//	(int) [SS:ESP +  32] = 0x0400 /* line command */;
//	(int) [SS:ESP +  36] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +  40] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  44] = /*  3 */ EBP /* x0 */;
	(int) [SS:ESP +  48] = /*  3 */ EBP /* y0 */;
	(int) [SS:ESP +  52] = EAX /* x1 */;
	(int) [SS:ESP +  56] =  20 /* y1 */;
	(char) [SS:ESP + 60] = CH /* color */;
	(int) [SS:ESP +  64] = /* 0x0000 */ ESI /* end of command */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall

	// ウィンドウクローズボタンを描く
	LEA(ECX, [EAX - 17]);
	EAX -= 2;
	ESI += 18;
	EBP += 2;
//	(int) [SS:ESP      ] = 0x0400 /* line command */;
//	(int) [SS:ESP +   4] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +   8] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  12] = ECX /* x0 */;
	(int) [SS:ESP +  16] = /*  5 */ EBP /* y0 */;
	(int) [SS:ESP +  20] = EAX /* x1 */;
	(int) [SS:ESP +  24] = /*  5 */ EBP /* y1 */;
	(int) [SS:ESP +  28] = 15 /* color */;
//	(int) [SS:ESP +  32] = 0x0400 /* line command */;
//	(int) [SS:ESP +  36] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +  40] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  44] = ECX /* x0 */;
	(int) [SS:ESP +  48] = /*  5 */ EBP /* y0 */;
	(int) [SS:ESP +  52] = ECX /* x1 */;
	(int) [SS:ESP +  56] = /* 18 */ ESI /* y1 */;
	(int) [SS:ESP +  60] = 15 /* color */;
//	(int) [SS:ESP +  64] = 0x0400 /* line command */;
	(char) [SS:ESP + 65] = 0x04 /* line command */;
//	(int) [SS:ESP +  68] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +  72] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  76] = EAX /* x0 */;
	(int) [SS:ESP +  80] = /*  5 */ EBP /* y0 */;
	(int) [SS:ESP +  84] = EAX /* x1 */;
	(int) [SS:ESP +  88] = /* 18 */ ESI /* y1 */;
	(int) [SS:ESP +  92] =  0 /* color */;
//	(int) [SS:ESP +  96] = 0x0400 /* line command */;
//	(int) [SS:ESP + 100] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP + 104] = EDX /* window(slot-no) */;
	(int) [SS:ESP + 108] = ECX /* x0 */;
	(int) [SS:ESP + 112] = /*  5 */ ESI /* y0 */;
	(int) [SS:ESP + 116] = EAX /* x1 */;
	(int) [SS:ESP + 120] = /* 18 */ ESI /* y1 */;
	(int) [SS:ESP + 124] =  0 /* color */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ECX++;
	EBP++;
	EAX--;
	ESI--;
//	(int) [SS:ESP +  64] = 0x0400 /* line command */;
//	(int) [SS:ESP +  68] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +  72] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  76] = EAX /* x0 */;
	(int) [SS:ESP +  80] = /*  5 */ EBP /* y0 */;
	(int) [SS:ESP +  84] = EAX /* x1 */;
	(int) [SS:ESP +  88] = /* 18 */ ESI /* y1 */;
	(int) [SS:ESP +  92] =  7 /* color */;
//	(int) [SS:ESP +  96] = 0x0400 /* line command */;
//	(int) [SS:ESP + 100] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP + 104] = EDX /* window(slot-no) */;
	(int) [SS:ESP + 108] = ECX /* x0 */;
	(int) [SS:ESP + 112] = /*  5 */ ESI /* y0 */;
	(int) [SS:ESP + 116] = EAX /* x1 */;
	(int) [SS:ESP + 120] = /* 18 */ ESI /* y1 */;
	(int) [SS:ESP + 124] =  7 /* color */;
	EAX--;
	ESI--;
//	(int) [SS:ESP +  32] = 0x0400 /* line command */;
//	(int) [SS:ESP +  36] = 0x0020 /* option(box-fill) */;
//	(int) [SS:ESP +  40] = EDX /* window(slot-no) */;
	(int) [SS:ESP +  44] = ECX /* x0 */;
	(int) [SS:ESP +  48] = /*  6 */ EBP /* y0 */;
	(int) [SS:ESP +  52] = EAX /* x1 */;
	(int) [SS:ESP +  56] = /* 18 */ ESI /* y1 */;
	(int) [SS:ESP +  60] =  8 /* color */;
	LEA(EBX, [SS:ESP + 32]);
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ESP += 512;
	POP(EBP);
	POP(ESI);
	return;
}

void near drawcomponent()
{
	WINDOW *win == DS:EDI;

	PUSH(ESI);
	PUSH(EBP);
	EDX = win->slot;
	ESP -= 512;

	// このウィンドウについているコンポーネントをサーチして、全て描画する
	LEA(EAX, win->children_back);
	ESI = win->children_next;
	if (EAX != ESI) {
		do {
			ESI -= 8;
			EAX = (int) [DS:ESI    ];
			ECX = (int) [DS:ESI + 4];
			if (EAX == 0x54584554 /* TEXT */) {
				// textbox
				TEXTBOX *textbox == DS:ESI;
				EAX = textbox->option;
				TEST(EAX, 0xf000);
				if (== 0) {
					// 普通のテキストボックス
					int *textbox_ycnt    == SS:ESP + 496;
					int *textbox_saveEDX == SS:ESP + 500; // win_slot(xdot)
					int *textbox_saveEBP == SS:ESP + 504; // work(xcnt)
					int *textbox_saveEDI == SS:ESP + 508; // win(buffer)
					TEST(EAX, 0x01);
					*textbox_saveEDX = EDX;
					*textbox_saveEBP = EBP;
					*textbox_saveEDI = EDI;
					if (!= 0) {
						ESP += 512 - 12;
						// EDX:win_slot, ESI:textbox
						EAX = 0x0010;
						textbox_drawback();
						ESP -= 512 - 12;
					}
					// バッファを参照して書き込む
					(int) [SS:ESP     ] = 0x0404; /* put text */
					(int) [SS:ESP +  4] = 0x0000; /* option */
					(int) [SS:ESP +  8] = EDX;
					EAX = textbox->charset;
					(int) [SS:ESP + 28] = EAX; /* charset */
					EAX = textbox->y_size;
					EBP = textbox->x_size;
					*textbox_ycnt = EAX;
					EDX = textbox->x0;
					EAX = textbox->y0;
					LEA(EDI, textbox->buffer);
					do {
						(int) [SS:ESP + 16] = EAX; /* y0 */
						do {
							// EDX, (EAX)から書き込むルーチン
							LEA(EBX, [SS:ESP + 40]);
							(int) [SS:ESP + 12] = EDX; /* x0 */
							EAX = (int) [DS:EDI    ];
							ECX = (int) [DS:EDI + 4];
							EDI += 8;
							(int) [DS:EBX - 4] = EAX;
							EAX = ECX;
							ECX >>= 16;
							EAX &= 0xffff;
							(int) [SS:ESP + 24] = ECX; /* backcolor */
							(int) [SS:ESP + 20] = EAX; /* color */
							EDX += 8; /* x */
							EBP--; /* xcnt */
							ECX = (int) [DS:EDI - 4];
							if (!= 0) {
								do {
									if (ECX != (int) [DS:EDI + 4])
										break;
									EAX = (int) [DS:EDI];
									EDI += 8;
									(int) [DS:EBX] = EAX;
									EBX += 4;
									EDX += 8; /* x */
									EBP--; /* xcnt */
								} while (!= 0);
							}
							(int) [DS:EBX] = 0x0000; /* end of command */
							EBX -= ESP;
							EBX -= 36;
							EBX /= 4;
							(int) [SS:ESP +  32] = EBX; /* length */
							EBX = ESP;
							DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
						} while (EBP != 0);
						EAX = (int) [SS:ESP + 16] /* y0 */;
						EBP = textbox->x_size;
						CL = (char) textbox->option;
						EAX += 8;
						TEST(CL, 0x10);
						if (== 0)
							EAX += 8;
						EDX = textbox->x0;
						*textbox_ycnt--;
					} while (!= 0);
					EDX = *textbox_saveEDX;
					EBP = *textbox_saveEBP;
					EDI = *textbox_saveEDI;
				} else {
					// wintitle
					// バッファを参照して書き込む
					int *textbox_saveESI == SS:ESP + 508; // textbox
					*textbox_saveESI = ESI;
					(int) [SS:ESP     ] = 0x0404; /* put text */
					(int) [SS:ESP +  4] = 0x0000; /* option */
				//	(int) [SS:ESP +  8] = EDX;
					EAX = win->mode0;
					(int) [SS:ESP + 12] = 24; /* x0 */
					asmout("MOV EAX,CS:[EAX*4+wintitle_colortable]");
					(int) [SS:ESP + 16] =  4; /* y0 */
					ECX = EAX;
					EAX &= 0xff;
					ECX /= 256;
					(int) [SS:ESP + 20] = EAX; /* color */
					(int) [SS:ESP + 24] = ECX; /* backcolor */
					EAX = textbox->charset;
					ECX = textbox->x_size;
					(int) [SS:ESP + 28] = EAX; /* charset */
					(int) [SS:ESP + 32] = ECX; /* length */
					ESI += 64; // seek buffer head
					LEA(EBX, [SS:ESP + 36]);
					do {
						EAX = (int) [DS:ESI];
						ESI += 8;
						(int) [DS:EBX] = EAX;
						EBX += 4;
						ECX--;
					} while (!= 0);
					(int) [DS:EBX] = /* 0x0000 */ ECX; /* end of command */
					EBX = ESP;
					DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
					ESI = *textbox_saveESI;
				}
			} else {
				INT(0x03);
			}
			LEA(EAX, win->children_back);
			ESI = (int) [DS:ESI + 12 /* chain_next */];
		} while (EAX != ESI);
	}
	ESP += 512;
	POP(EBP);
	POP(ESI);
	return;
}

void near textbox_drawback()
// EDX:win_slot, ESI:textbox
// EAX, ECX, EBXを破壊
{
	PUSH(EBP);
	PUSH(EAX);
	ESP -= 128 + 4;
	EBP = ESP;

	int *cmd == SS:EBP;
	TEXTBOX *textbox == DS:ESI;

	EAX = 0x0400;
	ECX = 0x0020;
	cmd[  0] = EAX /* line command */;
	cmd[  4] = ECX /* option(box-fill) */;
	cmd[  8] = EDX /* window(slot-no) */;
	cmd[ 32] = EAX /* line command */;
	cmd[ 36] = ECX /* option(box-fill) */;
	cmd[ 40] = EDX /* window(slot-no) */;
	cmd[ 64] = EAX /* line command */;
	cmd[ 68] = ECX /* option(box-fill) */;
	cmd[ 72] = EDX /* window(slot-no) */;
	cmd[ 96] = EAX /* line command */;
	cmd[100] = ECX /* option(box-fill) */;
	cmd[104] = EDX /* window(slot-no) */;
	cmd[128] = 0x0000 /* end of command */;
	EAX = textbox->x0;
	ECX = textbox->y0;
	EAX -= 3;
	ECX -= 3;
	cmd[ 12] = EAX /* x0 */;
	cmd[ 16] = ECX /* y0 */;
	cmd[ 24] = ECX /* y1 */;
	cmd[ 44] = EAX /* x0 */;
	cmd[ 48] = ECX /* y0 */;
	cmd[ 52] = EAX /* x1 */;
	cmd[ 76] = EAX /* x0 */;
	cmd[112] = ECX /* y0 */;
	EAX = textbox->x_size;
	ECX = textbox->y_size;
	EAX *= 8;
	ECX *= 8;
	TEST(textbox->option, 0x10);
	if (== 0) {
		ECX *= 2;
	}
	EAX += textbox->x0;
	ECX += textbox->y0;
	EAX += 2;
	ECX += 2;
	EBX = 0;
	cmd[ 20] = EAX /* x1 */;
	cmd[ 56] = ECX /* y1 */;
	cmd[ 80] = ECX /* y0 */;
	cmd[ 84] = EAX /* x1 */;
	cmd[ 88] = ECX /* y1 */;
	cmd[108] = EAX /* x0 */;
	cmd[116] = EAX /* x1 */;
	cmd[120] = ECX /* y1 */;
	LEA(EAX, [EBX + 7]);
	LEA(ECX, [EBX + 15]);
	cmd[ 28] = /*  7 */ EAX /* color */;
	cmd[ 60] = /*  7 */ EAX /* color */;
	cmd[ 92] = /* 15 */ ECX /* color */;
	cmd[124] = /* 15 */ ECX /* color */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	EAX = cmd[ 12];
	ECX = cmd[ 16];
	EAX++;
	ECX++;
	cmd[ 12] = EAX /* x0 */;
	cmd[ 16] = ECX /* y0 */;
	cmd[ 24] = ECX /* y1 */;
	cmd[ 44] = EAX /* x0 */;
	cmd[ 48] = ECX /* y0 */;
	cmd[ 52] = EAX /* x1 */;
	cmd[ 76] = EAX /* x0 */;
	cmd[112] = ECX /* y0 */;
	EAX = cmd[116];
	ECX = cmd[120];
	EAX--;
	ECX--;
	EBX = 0;
	cmd[ 20] = EAX /* x1 */;
	cmd[ 56] = ECX /* y1 */;
	cmd[ 80] = ECX /* y0 */;
	cmd[ 84] = EAX /* x1 */;
	cmd[ 88] = ECX /* y1 */;
	cmd[108] = EAX /* x0 */;
	cmd[116] = EAX /* x1 */;
	cmd[120] = ECX /* y1 */;
	LEA(EAX, [EBX + 8]);
	cmd[ 28] = /* 0 */ EBX /* color */;
	cmd[ 60] = /* 0 */ EBX /* color */;
	cmd[ 92] = /* 8 */ EAX /* color */;
	cmd[124] = /* 8 */ EAX /* color */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	EBX = [SS:ESP + 128 + 4];
	EAX = cmd[ 12];
	ECX = cmd[ 16];
	cmd[  4] = EBX; // opt
	EAX++;
	ECX++;
	cmd[ 12] = EAX /* x0 */;
	cmd[ 16] = ECX /* y0 */;
	EAX = cmd[116];
	ECX = cmd[120];
	EAX--;
	ECX--;
	cmd[ 20] = EAX /* x1 */;
	cmd[ 24] = ECX /* y1 */;
	EAX = textbox->backcolor;
	cmd[ 28] = EAX /* color */;
	cmd[ 32] = 0x0000 /* end of command */;
	EBX = ESP;
	DB(0x9a); DD(0); DW(0x0017); // GUIGUI統合shellcall
	ESP += 128 + 4;
	POP(EAX);
	POP(EBP);
	return;
}

